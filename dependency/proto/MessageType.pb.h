// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MessageType.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_MessageType_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_MessageType_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_MessageType_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_MessageType_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_MessageType_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace protobuf {

enum GameState : int {
  NULL_GAME_STATE = 0,
  GAME_START = 1,
  GAME_RUNNING = 2,
  GAME_END = 3,
  GameState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GameState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GameState_IsValid(int value);
constexpr GameState GameState_MIN = NULL_GAME_STATE;
constexpr GameState GameState_MAX = GAME_END;
constexpr int GameState_ARRAYSIZE = GameState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameState_descriptor();
template<typename T>
inline const std::string& GameState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GameState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GameState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GameState_descriptor(), enum_t_value);
}
inline bool GameState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GameState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GameState>(
    GameState_descriptor(), name, value);
}
enum PlaceType : int {
  NULL_PLACE_TYPE = 0,
  HOME = 1,
  SPACE = 2,
  BARRIER = 3,
  BUSH = 4,
  ECONOMY_RESOURCE = 5,
  ADDITION_RESOURCE = 6,
  CONSTRUCTION = 7,
  TRAP = 8,
  PlaceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PlaceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PlaceType_IsValid(int value);
constexpr PlaceType PlaceType_MIN = NULL_PLACE_TYPE;
constexpr PlaceType PlaceType_MAX = TRAP;
constexpr int PlaceType_ARRAYSIZE = PlaceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlaceType_descriptor();
template<typename T>
inline const std::string& PlaceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlaceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlaceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlaceType_descriptor(), enum_t_value);
}
inline bool PlaceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlaceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlaceType>(
    PlaceType_descriptor(), name, value);
}
enum ShapeType : int {
  NULL_SHAPE_TYPE = 0,
  CIRCLE = 1,
  SQUARE = 2,
  ShapeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ShapeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ShapeType_IsValid(int value);
constexpr ShapeType ShapeType_MIN = NULL_SHAPE_TYPE;
constexpr ShapeType ShapeType_MAX = SQUARE;
constexpr int ShapeType_ARRAYSIZE = ShapeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShapeType_descriptor();
template<typename T>
inline const std::string& ShapeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShapeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShapeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ShapeType_descriptor(), enum_t_value);
}
inline bool ShapeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShapeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShapeType>(
    ShapeType_descriptor(), name, value);
}
enum PlayerType : int {
  NULL_PLAYER_TYPE = 0,
  CHARACTER = 1,
  TEAM = 2,
  PlayerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PlayerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PlayerType_IsValid(int value);
constexpr PlayerType PlayerType_MIN = NULL_PLAYER_TYPE;
constexpr PlayerType PlayerType_MAX = TEAM;
constexpr int PlayerType_ARRAYSIZE = PlayerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerType_descriptor();
template<typename T>
inline const std::string& PlayerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerType_descriptor(), enum_t_value);
}
inline bool PlayerType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerType>(
    PlayerType_descriptor(), name, value);
}
enum CharacterType : int {
  NULL_CHARACTER_TYPE = 0,
  TangSeng = 1,
  SunWukong = 2,
  ZhuBajie = 3,
  ShaWujing = 4,
  BaiLongma = 5,
  Monkid = 6,
  JiuLing = 7,
  HongHaier = 8,
  NiuMowang = 9,
  TieShan = 10,
  ZhiZhujing = 11,
  Pawn = 12,
  CharacterType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CharacterType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CharacterType_IsValid(int value);
constexpr CharacterType CharacterType_MIN = NULL_CHARACTER_TYPE;
constexpr CharacterType CharacterType_MAX = Pawn;
constexpr int CharacterType_ARRAYSIZE = CharacterType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CharacterType_descriptor();
template<typename T>
inline const std::string& CharacterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CharacterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CharacterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CharacterType_descriptor(), enum_t_value);
}
inline bool CharacterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CharacterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CharacterType>(
    CharacterType_descriptor(), name, value);
}
enum CharacterState : int {
  NULL_CHARACTER_STATE = 0,
  IDLE = 1,
  HARVESTING = 2,
  ATTACKING = 3,
  SKILL_CASTING = 4,
  CONSTRUCTING = 5,
  MOVING = 6,
  BLIND = 7,
  KNOCKED_BACK = 8,
  STUNNED = 9,
  INVISIBLE = 10,
  HEALING = 11,
  BERSERK = 12,
  BURNED = 13,
  DECEASED = 14,
  CharacterState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CharacterState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CharacterState_IsValid(int value);
constexpr CharacterState CharacterState_MIN = NULL_CHARACTER_STATE;
constexpr CharacterState CharacterState_MAX = DECEASED;
constexpr int CharacterState_ARRAYSIZE = CharacterState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CharacterState_descriptor();
template<typename T>
inline const std::string& CharacterState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CharacterState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CharacterState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CharacterState_descriptor(), enum_t_value);
}
inline bool CharacterState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CharacterState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CharacterState>(
    CharacterState_descriptor(), name, value);
}
enum CharacterBuffType : int {
  NULL_CHARACTER_BUFF_TYPE = 0,
  ATTACK_BUFF1 = 1,
  ATTACK_BUFF2 = 2,
  ATTACK_BUFF3 = 3,
  DEFENSE_BUFF = 4,
  SPEED_BUFF = 5,
  VISION_BUFF = 6,
  CharacterBuffType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CharacterBuffType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CharacterBuffType_IsValid(int value);
constexpr CharacterBuffType CharacterBuffType_MIN = NULL_CHARACTER_BUFF_TYPE;
constexpr CharacterBuffType CharacterBuffType_MAX = VISION_BUFF;
constexpr int CharacterBuffType_ARRAYSIZE = CharacterBuffType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CharacterBuffType_descriptor();
template<typename T>
inline const std::string& CharacterBuffType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CharacterBuffType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CharacterBuffType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CharacterBuffType_descriptor(), enum_t_value);
}
inline bool CharacterBuffType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CharacterBuffType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CharacterBuffType>(
    CharacterBuffType_descriptor(), name, value);
}
enum EconomyResourceType : int {
  NULL_ECONOMY_RESOURCE_TYPE = 0,
  SMALL_ECONOMY_RESOURCE = 1,
  MEDIUM_ECONOMY_RESOURCE = 2,
  LARGE_ECONOMY_RESOURCE = 3,
  EconomyResourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EconomyResourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EconomyResourceType_IsValid(int value);
constexpr EconomyResourceType EconomyResourceType_MIN = NULL_ECONOMY_RESOURCE_TYPE;
constexpr EconomyResourceType EconomyResourceType_MAX = LARGE_ECONOMY_RESOURCE;
constexpr int EconomyResourceType_ARRAYSIZE = EconomyResourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EconomyResourceType_descriptor();
template<typename T>
inline const std::string& EconomyResourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EconomyResourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EconomyResourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EconomyResourceType_descriptor(), enum_t_value);
}
inline bool EconomyResourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EconomyResourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EconomyResourceType>(
    EconomyResourceType_descriptor(), name, value);
}
enum AdditionResourceType : int {
  NULL_ADDITION_RESOURCE_TYPE = 0,
  LIFE_POOL1 = 1,
  LIFE_POOL2 = 2,
  LIFE_POOL3 = 3,
  CRAZY_MAN1 = 4,
  CRAZY_MAN2 = 5,
  CRAZY_MAN3 = 6,
  QUICK_STEP = 7,
  WIDE_VIEW = 8,
  AdditionResourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AdditionResourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AdditionResourceType_IsValid(int value);
constexpr AdditionResourceType AdditionResourceType_MIN = NULL_ADDITION_RESOURCE_TYPE;
constexpr AdditionResourceType AdditionResourceType_MAX = WIDE_VIEW;
constexpr int AdditionResourceType_ARRAYSIZE = AdditionResourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AdditionResourceType_descriptor();
template<typename T>
inline const std::string& AdditionResourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AdditionResourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AdditionResourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AdditionResourceType_descriptor(), enum_t_value);
}
inline bool AdditionResourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AdditionResourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AdditionResourceType>(
    AdditionResourceType_descriptor(), name, value);
}
enum EconomyResourceState : int {
  NULL_ECONOMY_RESOURCE_STSTE = 0,
  HARVESTABLE = 1,
  BEING_HARVESTED = 2,
  HARVESTED = 3,
  EconomyResourceState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EconomyResourceState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EconomyResourceState_IsValid(int value);
constexpr EconomyResourceState EconomyResourceState_MIN = NULL_ECONOMY_RESOURCE_STSTE;
constexpr EconomyResourceState EconomyResourceState_MAX = HARVESTED;
constexpr int EconomyResourceState_ARRAYSIZE = EconomyResourceState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EconomyResourceState_descriptor();
template<typename T>
inline const std::string& EconomyResourceState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EconomyResourceState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EconomyResourceState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EconomyResourceState_descriptor(), enum_t_value);
}
inline bool EconomyResourceState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EconomyResourceState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EconomyResourceState>(
    EconomyResourceState_descriptor(), name, value);
}
enum AdditionResourceState : int {
  NULL_ADDITION_RESOURCE_STATE = 0,
  BEATABLE = 1,
  BEING_BEATEN = 2,
  BEATEN = 3,
  AdditionResourceState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AdditionResourceState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AdditionResourceState_IsValid(int value);
constexpr AdditionResourceState AdditionResourceState_MIN = NULL_ADDITION_RESOURCE_STATE;
constexpr AdditionResourceState AdditionResourceState_MAX = BEATEN;
constexpr int AdditionResourceState_ARRAYSIZE = AdditionResourceState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AdditionResourceState_descriptor();
template<typename T>
inline const std::string& AdditionResourceState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AdditionResourceState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AdditionResourceState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AdditionResourceState_descriptor(), enum_t_value);
}
inline bool AdditionResourceState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AdditionResourceState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AdditionResourceState>(
    AdditionResourceState_descriptor(), name, value);
}
enum EquipmentType : int {
  NULL_EQUIPMENT_TYPE = 0,
  SMALL_HEALTH_POTION = 1,
  MEDIUM_HEALTH_POTION = 2,
  LARGE_HEALTH_POTION = 3,
  SMALL_SHIELD = 4,
  MEDIUM_SHIELD = 5,
  LARGE_SHIELD = 6,
  SPEEDBOOTS = 7,
  PURIFICATION_POTION = 8,
  INVISIBILITY_POTION = 9,
  BERSERK_POTION = 10,
  EquipmentType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EquipmentType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EquipmentType_IsValid(int value);
constexpr EquipmentType EquipmentType_MIN = NULL_EQUIPMENT_TYPE;
constexpr EquipmentType EquipmentType_MAX = BERSERK_POTION;
constexpr int EquipmentType_ARRAYSIZE = EquipmentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EquipmentType_descriptor();
template<typename T>
inline const std::string& EquipmentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EquipmentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EquipmentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EquipmentType_descriptor(), enum_t_value);
}
inline bool EquipmentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EquipmentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EquipmentType>(
    EquipmentType_descriptor(), name, value);
}
enum ConstructionType : int {
  NULL_CONSTRUCTION_TYPE = 0,
  BARRACKS = 1,
  SPRING = 2,
  FARM = 3,
  ConstructionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConstructionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConstructionType_IsValid(int value);
constexpr ConstructionType ConstructionType_MIN = NULL_CONSTRUCTION_TYPE;
constexpr ConstructionType ConstructionType_MAX = FARM;
constexpr int ConstructionType_ARRAYSIZE = ConstructionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConstructionType_descriptor();
template<typename T>
inline const std::string& ConstructionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConstructionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConstructionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConstructionType_descriptor(), enum_t_value);
}
inline bool ConstructionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConstructionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConstructionType>(
    ConstructionType_descriptor(), name, value);
}
enum TrapType : int {
  NULL_TRAP_TYPE = 0,
  HOLE = 1,
  CAGE = 2,
  TrapType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TrapType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TrapType_IsValid(int value);
constexpr TrapType TrapType_MIN = NULL_TRAP_TYPE;
constexpr TrapType TrapType_MAX = CAGE;
constexpr int TrapType_ARRAYSIZE = TrapType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrapType_descriptor();
template<typename T>
inline const std::string& TrapType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrapType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrapType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrapType_descriptor(), enum_t_value);
}
inline bool TrapType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrapType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrapType>(
    TrapType_descriptor(), name, value);
}
enum NewsType : int {
  NULL_NEWS_TYPE = 0,
  TEXT = 1,
  BINARY = 2,
  NewsType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NewsType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NewsType_IsValid(int value);
constexpr NewsType NewsType_MIN = NULL_NEWS_TYPE;
constexpr NewsType NewsType_MAX = BINARY;
constexpr int NewsType_ARRAYSIZE = NewsType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NewsType_descriptor();
template<typename T>
inline const std::string& NewsType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NewsType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NewsType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NewsType_descriptor(), enum_t_value);
}
inline bool NewsType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NewsType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NewsType>(
    NewsType_descriptor(), name, value);
}
enum PlayerTeam : int {
  NULL_TEAM = 0,
  BUDDHISTS_TEAM = 1,
  MONSTERS_TEAM = 2,
  PlayerTeam_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PlayerTeam_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PlayerTeam_IsValid(int value);
constexpr PlayerTeam PlayerTeam_MIN = NULL_TEAM;
constexpr PlayerTeam PlayerTeam_MAX = MONSTERS_TEAM;
constexpr int PlayerTeam_ARRAYSIZE = PlayerTeam_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerTeam_descriptor();
template<typename T>
inline const std::string& PlayerTeam_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerTeam>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerTeam_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerTeam_descriptor(), enum_t_value);
}
inline bool PlayerTeam_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerTeam* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerTeam>(
    PlayerTeam_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::protobuf::GameState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::GameState>() {
  return ::protobuf::GameState_descriptor();
}
template <> struct is_proto_enum< ::protobuf::PlaceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::PlaceType>() {
  return ::protobuf::PlaceType_descriptor();
}
template <> struct is_proto_enum< ::protobuf::ShapeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::ShapeType>() {
  return ::protobuf::ShapeType_descriptor();
}
template <> struct is_proto_enum< ::protobuf::PlayerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::PlayerType>() {
  return ::protobuf::PlayerType_descriptor();
}
template <> struct is_proto_enum< ::protobuf::CharacterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::CharacterType>() {
  return ::protobuf::CharacterType_descriptor();
}
template <> struct is_proto_enum< ::protobuf::CharacterState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::CharacterState>() {
  return ::protobuf::CharacterState_descriptor();
}
template <> struct is_proto_enum< ::protobuf::CharacterBuffType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::CharacterBuffType>() {
  return ::protobuf::CharacterBuffType_descriptor();
}
template <> struct is_proto_enum< ::protobuf::EconomyResourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::EconomyResourceType>() {
  return ::protobuf::EconomyResourceType_descriptor();
}
template <> struct is_proto_enum< ::protobuf::AdditionResourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::AdditionResourceType>() {
  return ::protobuf::AdditionResourceType_descriptor();
}
template <> struct is_proto_enum< ::protobuf::EconomyResourceState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::EconomyResourceState>() {
  return ::protobuf::EconomyResourceState_descriptor();
}
template <> struct is_proto_enum< ::protobuf::AdditionResourceState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::AdditionResourceState>() {
  return ::protobuf::AdditionResourceState_descriptor();
}
template <> struct is_proto_enum< ::protobuf::EquipmentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::EquipmentType>() {
  return ::protobuf::EquipmentType_descriptor();
}
template <> struct is_proto_enum< ::protobuf::ConstructionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::ConstructionType>() {
  return ::protobuf::ConstructionType_descriptor();
}
template <> struct is_proto_enum< ::protobuf::TrapType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::TrapType>() {
  return ::protobuf::TrapType_descriptor();
}
template <> struct is_proto_enum< ::protobuf::NewsType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::NewsType>() {
  return ::protobuf::NewsType_descriptor();
}
template <> struct is_proto_enum< ::protobuf::PlayerTeam> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobuf::PlayerTeam>() {
  return ::protobuf::PlayerTeam_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_MessageType_2eproto
